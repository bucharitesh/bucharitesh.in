{
  "name": "game-of-life",
  "type": "registry:ui",
  "files": [
    {
      "path": "bucharitesh/game-of-life.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface GameOfLifeProps\n  extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  size?: number;\n  interval?: number;\n  backgroundColor?: string;\n  cellColor?: string;\n}\n\nconst GameOfLife = React.forwardRef<HTMLCanvasElement, GameOfLifeProps>(\n  (\n    {\n      className,\n      size = 12,\n      interval = 150,\n      backgroundColor = \"#000000\",\n      cellColor = \"#1e1e1e\",\n      ...props\n    },\n    ref\n  ) => {\n    const canvasRef = React.useRef<HTMLCanvasElement | null>(null);\n    const frameRef = React.useRef<number>(0);\n    const gridRef = React.useRef<boolean[][]>([]);\n    const lastUpdateRef = React.useRef<number>(0);\n    const transitionRef = React.useRef<{\n      from: boolean[][];\n      to: boolean[][];\n      progress: number;\n    } | null>(null);\n    const [isReady, setIsReady] = React.useState(false);\n\n    React.useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n\n      const ctx = canvas.getContext(\"2d\", { alpha: false });\n      if (!ctx) return;\n\n      let width = window.innerWidth;\n      let height = window.innerHeight;\n      let cols = Math.floor(width / size);\n      let rows = Math.floor(height / size);\n\n      const createGrid = (): boolean[][] => {\n        width = window.innerWidth;\n        height = window.innerHeight;\n        canvas.width = width;\n        canvas.height = height;\n        cols = Math.floor(width / size);\n        rows = Math.floor(height / size);\n\n        return Array.from({ length: cols }, () =>\n          Array.from({ length: rows }, () => Math.random() > 0.92)\n        );\n      };\n\n      const updateGrid = (grid: boolean[][]): boolean[][] => {\n        const next: boolean[][] = Array.from({ length: cols }, () =>\n          Array(rows).fill(false)\n        );\n\n        for (let i = 0; i < cols; i++) {\n          for (let j = 0; j < rows; j++) {\n            let neighbors = 0;\n\n            for (let dx = -1; dx <= 1; dx++) {\n              for (let dy = -1; dy <= 1; dy++) {\n                if (dx === 0 && dy === 0) continue;\n                const nx = (i + dx + cols) % cols;\n                const ny = (j + dy + rows) % rows;\n                neighbors += grid[nx][ny] ? 1 : 0;\n              }\n            }\n\n            next[i][j] = neighbors === 3 || (grid[i][j] && neighbors === 2);\n          }\n        }\n\n        return next;\n      };\n\n      const interpolateGrids = (fromGrid: boolean[][], toGrid: boolean[][]) => {\n        ctx.fillStyle = backgroundColor;\n        ctx.fillRect(0, 0, width, height);\n\n        for (let i = 0; i < cols; i++) {\n          for (let j = 0; j < rows; j++) {\n            const fromState = fromGrid[i][j];\n            const toState = toGrid[i][j];\n\n            if (fromState || toState) {\n              ctx.fillStyle = cellColor;\n              ctx.fillRect(i * size, j * size, size, size);\n            }\n          }\n        }\n      };\n\n      const render = (grid: boolean[][]) => {\n        ctx.fillStyle = backgroundColor;\n        ctx.fillRect(0, 0, width, height);\n\n        ctx.fillStyle = cellColor;\n\n        for (let i = 0; i < cols; i++) {\n          for (let j = 0; j < rows; j++) {\n            if (grid[i][j]) {\n              ctx.fillRect(i * size, j * size, size, size);\n            }\n          }\n        }\n      };\n\n      const startTransition = (fromGrid: boolean[][], toGrid: boolean[][]) => {\n        transitionRef.current = {\n          from: fromGrid.map((row) => [...row]),\n          to: toGrid.map((row) => [...row]),\n          progress: 0,\n        };\n      };\n\n      const animate = (timestamp: number) => {\n        if (timestamp - lastUpdateRef.current >= interval) {\n          if (gridRef.current) {\n            const nextGrid = updateGrid(gridRef.current);\n            startTransition(gridRef.current, nextGrid);\n            gridRef.current = nextGrid;\n          }\n          lastUpdateRef.current = timestamp;\n        }\n\n        // Handle transition animation\n        if (transitionRef.current) {\n          const { from, to } = transitionRef.current;\n          interpolateGrids(from, to);\n\n          transitionRef.current.progress += 0.1;\n          if (transitionRef.current.progress >= 1) {\n            transitionRef.current = null;\n            render(gridRef.current);\n          }\n        }\n\n        frameRef.current = requestAnimationFrame(animate);\n      };\n\n      let resizeTimeout: NodeJS.Timeout;\n      const handleResize = () => {\n        clearTimeout(resizeTimeout);\n        resizeTimeout = setTimeout(() => {\n          setIsReady(false);\n          const newGrid = createGrid();\n\n          if (gridRef.current) {\n            startTransition(gridRef.current, newGrid);\n          }\n\n          gridRef.current = newGrid;\n          setTimeout(() => setIsReady(true), 50);\n        }, 250);\n      };\n\n      gridRef.current = createGrid();\n      lastUpdateRef.current = performance.now();\n      frameRef.current = requestAnimationFrame(animate);\n      window.addEventListener(\"resize\", handleResize);\n      setIsReady(true);\n\n      return () => {\n        cancelAnimationFrame(frameRef.current);\n        window.removeEventListener(\"resize\", handleResize);\n        clearTimeout(resizeTimeout);\n      };\n    }, [size, interval, backgroundColor, cellColor]);\n\n    return (\n      <canvas\n        ref={React.useMemo(\n          () => (node: HTMLCanvasElement | null) => {\n            if (typeof ref === \"function\") ref(node);\n            else if (ref) ref.current = node;\n            canvasRef.current = node;\n          },\n          [ref]\n        )}\n        className={cn(\n          \"fixed inset-0 w-full h-full -z-10 transition-opacity duration-500\",\n          isReady ? \"opacity-100\" : \"opacity-0\",\n          className\n        )}\n        {...props}\n      />\n    );\n  }\n);\n\nGameOfLife.displayName = \"GameOfLife\";\n\nexport { GameOfLife };\nexport type { GameOfLifeProps };\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}